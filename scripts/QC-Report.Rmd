---
title: "GBS-Pipeline report"
subtitle: "QC Report"
author: "Daniel Fischer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
    df_print: paged
    code_folding: show
---

```{r setup, include=FALSE}
.libPaths()
#.libPaths(c("/projappl/project_2001746/R/libraries", .libPaths()))
#library("knitr")
library("GenomicTools")
library("Luke")
library("xtable")   # Needed for LaTeX output of the tables
library("viridis")  # Needed for the colouring of the plots
library("rjson")    # Needed for multiqc dgsb etail data
library("adegenet")
library("vcfR")
library("DT")
library("kableExtra")
library("ICS")
library("tsne")
#library("lle")
library("kernlab")
#library("REPPlab")
#library("RDRToolbox")
library("destiny")
library("ggplot2")
options(scipen=999,
        stringsAsFactors=FALSE)
knitr::opts_chunk$set(echo = FALSE,
                      cache = FALSE,
                      cache.lazy = FALSE,
                      dev = c('png', 'pdf'),
                      fig.align = 'center', fig.height = 5, fig.width = 8.5)
report.colours <-c("#FF8200", "#00B5E2", "#78BE20", "#7F3F98", "#E13C98", "#0033A0", "#54585A")

mockClusters.file <- "GSC.MR.Clusters.fa"
mockReference.file <- "GSC.MR.Genome.fa"
# To run locally on terminal type this command in the pipeline folder:
# R -e "rmarkdown::render('./scripts/workflow-report.Rmd',output_file='./finalReport.html')"

if(!is.element("snakemake",ls())){
  projFolder <- "/scratch/project_2001746/TestProject"
  pipelineFolder <- "~/git/Pipeline-GBS/"
  pipelineConfig.file <- "/scratch/project_2001746/TestProject/GBS-pipeline_config.yaml"
  refGenome.file <- "hermetiaRef_112020.fasta"
}
refGenome.file <- basename(refGenome.file)
ifelse(refGenome.file == "", refAvail <- FALSE, refAvail <- TRUE)
```

```{r help functions}
vectorToDF.int <- function(x, sep=" ", names=NULL, autoCoerc=TRUE){
  x.split <- strsplit(x, sep)
  no.columns <- length(x.split[[1]])
  no.rows <- length(x.split)
  out <- as.data.frame(matrix(NA, ncol=no.columns, nrow=no.rows))
  for(i in 1:no.columns){
    out[,i] <- sapply(x.split,"[", i)
  }
  names(out) <- names
  if(autoCoerc){
    for(i in 1:no.columns){
      ac <- suppressWarnings(as.numeric(out[1,i]))
      if(!is.na(ac)){
      out[,i] <- as.numeric(out[,i])
      }
      
    }
  }
  out
}


getConfigField <- function(x, from=pipelineConfig){
  out <- c()
  
  if(length(x)==1){
    pos <- grep(x, from)
    out <- from[pos]
    
    out <- gsub(x, "", out)
    out <- gsub('\"','',out)
    out <- gsub(' ','',out)
    out <- gsub(':','',out)
    out <- gsub('#.*','',out)
  } else {
    # Get here the part for the subfields
    
  }
  
  out
}

class.table <- function(x, classes=NULL){
  if(is.null(classes)){
    out <- table(x)
  } else {
    out <- rep(0, length(classes))
    for(i in 1:length(classes)){
      out[i] <- sum(x==classes[i])
    }
    names(out) <- classes
  }
  out
}

# alternative colours c(viridis(20)[8], viridis(20)[16])
plotFastQCFeature <- function(x,y, labels=c("R1", "R2"), col=c(report.colours[1], report.colours[2]), feature="total_deduplicated_percentage", axes=TRUE){
  x.values <- as.vector(as.matrix(x[feature]))
  y.values <- as.vector(as.matrix(y[feature]))
  
  if(feature=="total_deduplicated_percentage"){
    label <- "De-Duplication level in %"
  } else if (feature=="X.GC"){
    label <- "GC content in %"
  } else if (feature=="avg_sequence_length"){
    label <- "Feature length"
  } else if (feature=="Total.Sequences"){
    label <- "Total sequences"
  }
  
  barplot(rbind(x.values, y.values), beside=TRUE, ylab=label, col=col)

  if(axes) axis(1, at=seq(2,3*nrow(x), by=3), paste(substr(x$Sample,1,10),"..."), las=2, cex=0.1)
  
  legend("bottomright", pch=c(20,20), col=col, legend=labels, fill="white")
}

plotFastQCJSONFeature <- function(x,y, labels, feature){
  par(mfrow=c(1,2))
  ymax <- max(rbind(x[feature][[1]],y[feature][[1]]))
  ymax <- ceiling(ymax+ymax*0.1)
  if(feature=="sequenceQuality") ymax <- 40
  boxplot(t(x[feature][[1]]), ylim=c(0,ymax))
  boxplot(t(y[feature][[1]]), ylim=c(0,ymax))
}

plotMQCFeature <- function(x, y, labels, feature){
  
  result1 <- fromJSON(file=file.path(x,"multiqc_data","multiqc_data.json"))
  result2 <- fromJSON(file=file.path(y,"multiqc_data","multiqc_data.json"))
  
  data1 <- get(feature, result1$report_plot_data)$datasets[[1]]
  data2 <- get(feature, result2$report_plot_data)$datasets[[1]]
  
  pos1 <-  length(sapply(data1,"[",2)[[1]]) - 1
  pos2 <-  length(sapply(data2,"[",2)[[1]]) - 1
  
  obs1 <- length(sapply(sapply(sapply(data1,"[",2),"[",1),"[",2))
  obs2 <- length(sapply(sapply(sapply(data2,"[",2),"[",1),"[",2))

  plotData1 <- matrix(-1, ncol=pos1, nrow=obs1)
  tmp <- sapply(sapply(data1,"[",2)[[1]],"[",1) 
  colnames(plotData1) <-  tmp[-length(tmp)]
  
  plotData2 <- matrix(-1, ncol=pos2, nrow=obs2)
  tmp <- sapply(sapply(data2,"[",2)[[1]],"[",1)
  colnames(plotData2) <- tmp[-length(tmp)]
  
  for(i in 1:pos1){
    plotData1[,i] <- sapply(sapply(sapply(data1,"[",2),"[",i),"[",2)
  }
  
  for(i in 1:pos2){
    plotData2[,i] <- sapply(sapply(sapply(data2,"[",2),"[",i),"[",2)
  }

  par(mfrow=c(1,2))
  ymax1 <- max(plotData1)
  ymax2 <- max(plotData2)
  ymax <- max(ymax1, ymax2)
  ymax <- ceiling(ymax+ymax*0.1)
  
  if(feature=="sequenceQuality") ymax <- 40
  boxplot(plotData1, ylim=c(0,ymax), pch=".", xaxt="n")
  #  axis(1,at=2:ncol(data1),gsub("X","",colnames(data1)[-1]))
  boxplot(plotData2, ylim=c(0,ymax), pch=".", xaxt="n")
  #  axis(1,at=2:ncol(data2),gsub("X","",colnames(data2)[-1]))
}

```


```{r help function 2}
getFastQCJSON <- function(path){
  
  x_file <- file.path(path)
  x <- fromJSON(paste(readLines(x_file), collapse=""))

  tmp <- x$report_plot_data$fastqc_per_base_sequence_quality_plot$datasets[[1]]
  datapoints <- length(tmp[[1]]$data)
  sequenceQuality <- matrix(-1, nrow= datapoints, ncol=length(tmp))
  rownames(sequenceQuality) <- sapply(tmp[[1]]$data,"[",1)
  for(i in 1:length(tmp)){
    sequenceQuality[,i] <- sapply(tmp[[i]]$data,"[",2)[1:datapoints]
  }  
  
  tmp <- x$report_plot_data$fastqc_per_base_n_content_plot$datasets[[1]]
  perBaseN <- matrix(-1, nrow= length(tmp[[1]]$data), ncol=length(tmp))
  rownames(perBaseN) <- sapply(tmp[[1]]$data,"[",1)
  for(i in 1:length(tmp)){
    perBaseN[,i] <- sapply(tmp[[i]]$data,"[",2)[1:datapoints]
  }
  
  output <- list(sequenceQuality=sequenceQuality,
                 perBaseN=perBaseN)
  output
}
```

# General workflow

## Directed acyclic graph (DAG)

The DAG of the used pipeline with rule dependencies.

```{r import workflow, echo=FALSE, fig.cap="Overview of the applied workflow", out.width = '100%'}
if(file.exists(file.path(projFolder,"workflow.png"))) knitr::include_graphics(file.path(projFolder,"workflow.png"))
```
# Basic stats

```{r get pipeline version}
pipeSMK <- readLines(file.path(pipelineFolder,"GBS-pipeline.smk"))
pipeVersion <- gsub("##### Version: ","",pipeSMK[grep("##### Version:", pipeSMK)])
```

```{r import barcodesID, results="asis"}
#barcodes <- read.table(file.path(projFolder, "barcodesID.txt"))
#rawsamples <- read.table(file.path(projFolder, "rawsamples"))
#sampleInfo <- read.table(file.path(projFolder, "sampleInfo.txt"), header=TRUE)
pipelineConfig <- readLines(pipelineConfig.file)

sampleSheet.file <- getConfigField("samplesheet-file")
sampleSheet <- read.table(sampleSheet.file, sep="\t", header=TRUE)

sampleInfo.file <- getConfigField("sampleinfo-file")
sampleInfo <- NULL

if(length(sampleInfo.file)>0 ) sampleInfo <- read.table(sampleInfo.file, sep="\t", header=TRUE)

#projectFolder.info <- trimws(gsub("project-folder:","", pipelineConfig[grep("project-folder:", pipelineConfig)]))
#pipelineFolder.info <- trimws(gsub("pipeline-folder:","", pipelineConfig[grep("pipeline-folder:", pipelineConfig)]))
#pipelineConfig.info <- trimws(gsub("pipeline-config:","", pipelineConfig[grep("pipeline-config:", pipelineConfig)]))

projectFolder.info <- getConfigField("project-folder")
pipelineFolder.info <- getConfigField("pipeline-folder")
pipelineConfig.info <- pipelineConfig.file

groupingNames <- "No file with sample information provided ('sampleinfo-file'-field)!"
numberGroupingNames <- 0
if(!is.null(sampleInfo)){
  groupingNames <- colnames(sampleInfo[,-1])
  numberGroupingNames <- length(groupingNames)
} 

mockSamples <- unique(sampleSheet$sample_name[sampleSheet$useForMock=="YES"])

out <- data.frame(c("Number of raw-samples",
                    "Number of samples (after concatenating)",
                    "No. of grouping information",
                    "Grouping names",
                    "No. of mock reference samples",
                    "Samples used for mock reference",
                    "Used reference genome",
                    "Pipeline version",
                    "Project folder",
                    "Pipeline folder",
                    "Pipeline config"),
                  c(length(unique(sampleSheet$rawsample)),
                    length(unique(sampleSheet$sample_name)),
                    numberGroupingNames,
                    groupingNames,
                    length(mockSamples),
                    paste(mockSamples,collapse=", "),
                    basename(refGenome.file),
                    pipeVersion,
                    projectFolder.info,
                    pipelineFolder.info,
                    pipelineConfig.info))

out_html <- knitr::kable(out, col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")
```

## Concatenating stats
As the concatenating is a crucial step in this pipeline, it is important to make this correct. As a double check that things went right, we check how
many raw samples were concatenated per sample. We do this visually. Basically, the height of the bars should correspond to your number of used lanes,
normally 1,2 or 4. Sometimes, you might want to concatenate also more files together (e.g. technical replicates), in this case the bar can be also higher.

```{r import the conc report files}
conc.reports.files <- list.files(file.path(projFolder, "FASTQ", "CONCATENATED"), pattern="*.report")

conc.reports <- list()
conc.reports[[1]] <- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.reports.files[1]))

for(i in 2:length(conc.reports.files)){
  conc.reports[[i]]<- read.table(file.path(projFolder, "FASTQ", "CONCATENATED", conc.reports.files[i]))
}
```

```{r visualize concatenation reports}
par(oma=c(6,5,0,0))
labels <- gsub(".merged.fastq.gz.report","",conc.reports.files)
barplot(sapply(conc.reports,nrow), ylab="Concatenated files", names=labels, las=2, col=report.colours[1])
```


# Quality checks

In this chapter the results from the FastQC part of the pipeline are presented. First, the basic stats on the very raw data are shown, then the concatenated (in case samples were split across different lanes) and then the final reads, after trimming.

After that, the concatenated reads are comapred against the trimmed reads.

```{r import multiqc data}
# Import the FastQC/MultiQC output for the RAW data
rawFastQC.R1 <- read.table(file.path(projFolder,"QC","RAW","multiqc_R1","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
rawFastQC.R2 <- read.table(file.path(projFolder,"QC","RAW","multiqc_R2","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
#rawFastQCJSON.R1 <- getFastQCJSON(file.path(projFolder, "QC", "RAW", "multiqc_R1", "multiqc_data", "multiqc_data.json"))
#rawFastQCJSON.R2 <- getFastQCJSON(file.path(projFolder, "QC", "RAW", "multiqc_R2", "multiqc_data", "multiqc_data.json"))

# Import the FastQC/MultiQC output for the CONCATENATED data
conFastQC.R1 <- read.table(file.path(projFolder,"QC","CONCATENATED","multiqc_R1","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
conFastQC.R2 <- read.table(file.path(projFolder,"QC","CONCATENATED","multiqc_R2","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
conFastQCJSON.R1 <- getFastQCJSON(file.path(projFolder, "QC", "CONCATENATED", "multiqc_R1", "multiqc_data", "multiqc_data.json"))
conFastQCJSON.R2 <- getFastQCJSON(file.path(projFolder, "QC", "CONCATENATED", "multiqc_R2", "multiqc_data", "multiqc_data.json"))

# Import the FastQC/MultiQC output for the TRIMMED data
trimmedFastQC.R1 <- read.table(file.path(projFolder,"QC","TRIMMED","multiqc_R1","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
trimmedFastQC.R2 <- read.table(file.path(projFolder,"QC","TRIMMED","multiqc_R2","multiqc_data","multiqc_fastqc.txt"), header=TRUE, sep="\t")
trimmedFastQCJSON.R1 <- getFastQCJSON(file.path(projFolder, "QC", "TRIMMED", "multiqc_R1", "multiqc_data", "multiqc_data.json"))
trimmedFastQCJSON.R2 <- getFastQCJSON(file.path(projFolder, "QC", "TRIMMED", "multiqc_R2", "multiqc_data", "multiqc_data.json"))
```


## Raw data
These are the reads, as they come from the sequencer, no trimming, no nothing.

### De-duplication percent

```{r raw data duplication percent}
#par(mar=c(10,5,1,1))
plotFastQCFeature(rawFastQC.R1, rawFastQC.R2, feature="total_deduplicated_percentage", axes=FALSE)
abline(h=50, lty="dotted", col="red")
```

A list of samples over a certain threshold (>50%)

```{r table samples duplication under threshold raw}
tmp <- cbind(rawFastQC.R1$Sample,rawFastQC.R1["total_deduplicated_percentage"])
tmp <- tmp[tmp[,2]>50,]
if(nrow(tmp)>0){
rownames(tmp) <- 1:nrow(tmp)
colnames(tmp) <- c("Rawsample", "Total deduplicated percentage")

datatable(tmp)
}
```

### GC content

```{r raw data qc content}
#par(mar=c(10,5,1,1))
plotFastQCFeature(rawFastQC.R1, rawFastQC.R2, feature="X.GC", axes=FALSE)
abline(h=60, lty="dotted", col="red")
abline(h=30, lty="dotted", col="red")
```

A list of samples under a certain threshold (<30%)

```{r table samples GC content}
tmp <- cbind(rawFastQC.R1$Sample,rawFastQC.R1["X.GC"])
tmp <- tmp[tmp[,2]<30,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Rawsample", "GC content")
  #knitr::kable(tmp) %>% kable_styling
  datatable(tmp)
}
```

### Sequence length

```{r raw data sequence length}
#par(mar=c(10,5,1,1))
plotFastQCFeature(rawFastQC.R1, rawFastQC.R2, feature="avg_sequence_length", axes=FALSE)
tmp <- rawFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
abline(h=tmp*0.9, lty="dotted", col="red")
```

A list of samples with average sequence length smaller then overall average minus 10%.

```{r table samples sequence length}
tmp <- rawFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
th <- tmp*0.9

tmp <- cbind(rawFastQC.R1$Sample,rawFastQC.R1["avg_sequence_length"])

tmp <- tmp[tmp[,2]<th,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Rawsample", "Avg sequence length")
  #knitr::kable(tmp) %>% kable_styling
  datatable(tmp)
}
```

### Total sequences

```{r raw data total sequences}
#par(mar=c(10,5,1,1))
plotFastQCFeature(rawFastQC.R1, rawFastQC.R2, feature="Total.Sequences", axes=FALSE)
```

### Quality value distribution
```{r}
qcFiles.R1.raw <- paste0(sampleSheet$rawsample, "_R1_qualdist.txt")
qcFiles.R2.raw <- paste0(sampleSheet$rawsample, "_R2_qualdist.txt")

qcQual.R1.raw <- vectorToDF.int(trimws(readLines(file.path(projFolder,"QC", "RAW", qcFiles.R1.raw[1]))[-1]))
qcQual.R2.raw <- vectorToDF.int(trimws(readLines(file.path(projFolder,"QC", "RAW", qcFiles.R2.raw[1]))[-1]))

colnames(qcQual.R1.raw) <- c(gsub("_qualdist.txt","", qcFiles.R1.raw[1]), "Quality")
colnames(qcQual.R2.raw) <- c(gsub("_qualdist.txt","", qcFiles.R2.raw[1]), "Quality")

for(i in 2:length(qcFiles.R1.raw)){
    fileIn <- readLines(file.path(projFolder,"QC", "RAW", qcFiles.R1.raw[i]))[-1]
    if(length(fileIn)>0){
      tmp <- vectorToDF.int(trimws(fileIn))
      colnames(tmp) <- c(gsub("_qualdist.txt","", qcFiles.R1.raw[i]), "Quality")
    } else {
      tmp <- data.frame(qcQual.R1.raw$Quality, 0)
      colnames(tmp) <- c("Quality", gsub("_qualdist.txt","", qcFiles.R1.raw[i]))
    }

      qcQual.R1.raw <- merge(qcQual.R1.raw, tmp, all=TRUE)      
}

qcQual.R1.raw[is.na(qcQual.R1.raw)] <- 0

for(i in 2:length(qcFiles.R2.raw)){
    fileIn <- readLines(file.path(projFolder,"QC", "RAW", qcFiles.R2.raw[i]))[-1]
    if(length(fileIn)>0){
      tmp <- vectorToDF.int(trimws(fileIn))
      colnames(tmp) <- c(gsub("_qualdist.txt","", qcFiles.R2.raw[i]), "Quality")
    } else {
      tmp <- data.frame(qcQual.R2.raw$Quality, 0)
      colnames(tmp) <- c("Quality", gsub("_qualdist.txt","", qcFiles.R2.raw[i]))
    }

      qcQual.R2.raw <- merge(qcQual.R2.raw, tmp, all=TRUE)      
}

qcQual.R2.raw[is.na(qcQual.R2.raw)] <- 0

```

```{r}
plotThis <- as.matrix(qcQual.R1.raw[,-1])
rownames(plotThis) <- as.vector(as.matrix(qcQual.R1.raw[,1]))
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(plotThis, las=2, col=1:nrow(plotThis), main="Read 1 Quality scores")
legend("topright", inset=c(-0.2,0), legend=rownames(plotThis)[(nrow(plotThis)):1], fill=nrow(plotThis):1)
```

```{r}
plotThis <- as.matrix(qcQual.R2.raw[,-1])
rownames(plotThis) <- as.vector(as.matrix(qcQual.R2.raw[,1]))
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(plotThis, las=2, col=1:nrow(plotThis), main="Read 2 Quality scores")
legend("topright", inset=c(-0.2,0), legend=rownames(plotThis)[(nrow(plotThis)):1], fill=nrow(plotThis):1)
```

### Summary
```{r raw data summary stats}
mqcStats.raw <- read.table(file.path(projFolder,"QC","RAW","multiqc_R1", "multiqc_data", "multiqc_fastqc.txt"), header=TRUE, sep="\t")
tmp <- mqcStats.raw[,-c(1:4,7,11:21)]

totalRawSequences <- sum(mqcStats.raw$Total.Sequences)
out <- c(totalRawSequences,sd(tmp[,1]),apply(tmp,2,mean))
names(out) <- c("Tot. number sequences",
                "SD total sequences",
                "Avg. total sequences",
                "Avg. poor quality",
                "Avg. GC Percent",
                "Avg. deplication percent",
                "Avg. sequence length")

out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")

out <- t(as.data.frame(as.matrix((summary(tmp[,1])))))
rownames(out) <- "5-point summary of total sequences"
out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), "html")
kable_styling(out_html, "striped", position = "left")
```


## Concatenated data
In this section samples lanes are concatentated, but no other steps were performed.

### De-Duplication percent

```{r conc data duplication percent}
#par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.R1, conFastQC.R2, feature="total_deduplicated_percentage", axes=FALSE)
abline(h=50, lty="dotted", col="red")
```

A list of samples over a certain threshold (>50%)

```{r table samples duplication under threshold conc}
tmp <- cbind(conFastQC.R1$Sample,conFastQC.R1["total_deduplicated_percentage"])
tmp <- tmp[tmp[,2]>50,]
if(nrow(tmp)>0){
rownames(tmp) <- 1:nrow(tmp)
colnames(tmp) <- c("Sample", "Total deduplicated percentage")

datatable(tmp)
}
```

### GC content

```{r conc data qc content}
#par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.R1, conFastQC.R2, feature="X.GC", axes=FALSE)
abline(h=60, lty="dotted", col="red")
abline(h=30, lty="dotted", col="red")
```

A list of samples under a certain threshold (<30%)

```{r table samples GC content conc}
tmp <- cbind(conFastQC.R1$Sample,conFastQC.R1["X.GC"])
tmp <- tmp[tmp[,2]<30,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Sample", "GC content")
  datatable(tmp)
}
```

### Sequence length

```{r con data sequence length}
#par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.R1, conFastQC.R2, feature="avg_sequence_length", axes=FALSE)
tmp <- conFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
abline(h=tmp*0.9, lty="dotted", col="red")
```

A list of samples with average sequence length smaller then overall average minus 10%.

```{r table samples sequence length conc}
tmp <- conFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
th <- tmp*0.9

tmp <- cbind(conFastQC.R1$Sample, conFastQC.R1["avg_sequence_length"])

tmp <- tmp[tmp[,2]<th,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Sample", "Avg sequence length")
  datatable(tmp)
}
```

### Total sequences

```{r con data total sequences}
par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.R1, conFastQC.R2, feature="Total.Sequences")
```

### Quality value distribution
```{r}
qcFiles.conc <- list.files(file.path(projFolder,"QC", "CONCATENATED"), pattern="*qualdist.txt")
qcQual.conc <- fread(file.path(projFolder,"QC", "CONCATENATED", qcFiles.conc[1]), skip=1)
colnames(qcQual.conc) <- c(gsub("_qualdist.txt","", qcFiles.conc[1]), "Quality")

for(i in 2:length(qcFiles.conc)){
    tmp <- fread(file.path(projFolder,"QC", "CONCATENATED", qcFiles.conc[i]), skip=1)
    colnames(tmp) <- c(gsub("_qualdist.txt","", qcFiles.conc[i]), "Quality")
    qcQual.conc <- merge(qcQual.conc, tmp, all=TRUE)
}
qcQual.conc[is.na(qcQual.conc)] <- 0

```

```{r}
plotThis <- as.matrix(qcQual.conc[,-1])
rownames(plotThis) <- as.vector(as.matrix(qcQual.conc[,1]))
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(plotThis, las=2, col=1:nrow(plotThis))
legend("topright", inset=c(-0.2,0), legend=rownames(plotThis)[(nrow(plotThis)):1], fill=nrow(plotThis):1)
```

### Per base N content (left: R1, right: R2)

```{r con data per base n content}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="perBaseN")

plotMQCFeature(x=file.path(projFolder,"QC","CONCATENATED","multiqc_R1"),
               y=file.path(projFolder,"QC","CONCATENATED","multiqc_R2"),
               feature="fastqc_per_base_n_content_plot")
```

### Per base quality (left: R1, right: R2)
```{r con data per base sequence quality}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="sequenceQuality")

plotMQCFeature(x=file.path(projFolder,"QC","CONCATENATED","multiqc_R1"),
               y=file.path(projFolder,"QC","CONCATENATED","multiqc_R2"),
               feature="fastqc_per_base_sequence_quality_plot")
```

### Summary
```{r conc data summary stats}
mqcStats.conc <- read.table(file.path(projFolder,"QC","CONCATENATED","multiqc_R1", "multiqc_data", "multiqc_fastqc.txt"), header=TRUE, sep="\t")
tmp <- mqcStats.conc[,-c(1:4,7,11:21)]

totalConcSequences <- sum(mqcStats.conc$Total.Sequences)
out <- c(totalConcSequences,apply(tmp,2,mean))
names(out) <- c("Tot. number sequences",
                "Avg. total sequences",
                "Avg. poor quality",
                "Avg. GC Percent",
                "Avg. deplication percent",
                "Avg. sequence length")

out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")

out <- t(as.data.frame(as.matrix((summary(tmp[,1])))))
rownames(out) <- "5-point summary of total sequences"
out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), "html")
kable_styling(out_html, "striped", position = "left")
```


## Trimmed data

### De-Duplication percent

```{r trimmed data duplication percent}
#par(mar=c(10,5,1,1))
plotFastQCFeature(trimmedFastQC.R1, trimmedFastQC.R2, feature="total_deduplicated_percentage", axes=FALSE)
abline(h=50, lty="dotted", col="red")
```

A list of samples over a certain threshold (>50%)

```{r table samples duplication under threshold trimmed}
tmp <- cbind(trimmedFastQC.R1$Sample,trimmedFastQC.R1["total_deduplicated_percentage"])
tmp <- tmp[tmp[,2]>50,]
if(nrow(tmp)>0){
rownames(tmp) <- 1:nrow(tmp)
colnames(tmp) <- c("Sample", "Total deduplicated percentage")

datatable(tmp)
}
```

### QC content

```{r trimmed data qc content}
#par(mar=c(10,5,1,1))
plotFastQCFeature(trimmedFastQC.R1, trimmedFastQC.R2, feature="X.GC", axes=FALSE)
abline(h=60, lty="dotted", col="red")
abline(h=30, lty="dotted", col="red")
```

A list of samples under a certain threshold (<30%)

```{r table samples GC content trimmed}
tmp <- cbind(trimmedFastQC.R1$Sample, trimmedFastQC.R1["X.GC"])
tmp <- tmp[tmp[,2]<30,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Sample", "GC content")
  #knitr::kable(tmp) %>% kable_styling
  datatable(tmp)
}
```
### Sequence length

```{r trimmed data sequence length}
#par(mar=c(10,5,1,1))
plotFastQCFeature(trimmedFastQC.R1, trimmedFastQC.R2, feature="avg_sequence_length", axes=FALSE)
tmp <- trimmedFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
abline(h=tmp*0.9, lty="dotted", col="red")
```

A list of samples with average sequence length smaller then overall average minus 10%.

```{r table samples sequence length trimmed}
tmp <- trimmedFastQC.R1["avg_sequence_length"]
tmp <- mean(as.vector(as.matrix((tmp)))) 
th <- tmp*0.9

tmp <- cbind(trimmedFastQC.R1$Sample, trimmedFastQC.R1["avg_sequence_length"])

tmp <- tmp[tmp[,2]<th,]
if(nrow(tmp)>0){
  rownames(tmp) <- 1:nrow(tmp)
  colnames(tmp) <- c("Sample", "Avg sequence length")
  #knitr::kable(tmp) %>% kable_styling
  datatable(tmp)
}
```

### Total sequences

```{r trimmed data total sequences}
par(mar=c(10,5,1,1))
plotFastQCFeature(trimmedFastQC.R1, trimmedFastQC.R2, feature="Total.Sequences")
```

```{r}
totalSequences <- trimmedFastQC.R1[,c(1,5)]
totalSequences[,1] <- gsub(".R1","",totalSequences[,1])
```

### Quality value distribution
```{r}
qcFiles.trimmed <- list.files(file.path(projFolder,"QC", "TRIMMED"), pattern="*qualdist.txt")
qcQual.trimmed <- fread(file.path(projFolder,"QC", "TRIMMED", qcFiles.trimmed[1]), skip=1)
colnames(qcQual.trimmed) <- c(gsub("_qualdist.txt","", qcFiles.trimmed[1]), "Quality")

for(i in 2:length(qcFiles.trimmed)){
    tmp <- fread(file.path(projFolder,"QC", "TRIMMED", qcFiles.trimmed[i]), skip=1)
    colnames(tmp) <- c(gsub("_qualdist.txt","", qcFiles.trimmed[i]), "Quality")
    qcQual.trimmed <- merge(qcQual.trimmed, tmp, all=TRUE)
}
qcQual.trimmed[is.na(qcQual.trimmed)] <- 0
```

```{r}
plotThis <- as.matrix(qcQual.trimmed[,-1])
rownames(plotThis) <- as.vector(as.matrix(qcQual.trimmed[,1]))
par(mar=c(15,5,2,8), xpd=TRUE)
barplot(plotThis, las=2, col=1:nrow(plotThis))
legend("topright", inset=c(-0.2,0), legend=rownames(plotThis)[(nrow(plotThis)):1], fill=nrow(plotThis):1)
```

### Per base N content

```{r trimmed data per base n content}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="perBaseN")

plotMQCFeature(x=file.path(projFolder,"QC","TRIMMED","multiqc_R1"),
               y=file.path(projFolder,"QC","TRIMMED","multiqc_R2"),
               feature="fastqc_per_base_n_content_plot")
```

### Per base quality (left: R1, right: R2)
```{r trimmed data per base sequence quality}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="sequenceQuality")

plotMQCFeature(x=file.path(projFolder,"QC","TRIMMED","multiqc_R1"),
               y=file.path(projFolder,"QC","TRIMMED","multiqc_R2"),
               feature="fastqc_per_base_sequence_quality_plot")
```


### Length distribution trimmed reads
From the trimlog we get more statistics on the output of the trimming. Include the trimlog data also here as density plots.

```{r}
cutLogs.files <- list.files(file.path(projFolder, "logs", "CUTADAPT"), pattern="cutadapt*")
cutLogs <- suppressWarnings(fread(file.path(projFolder, "logs", "CUTADAPT", cutLogs.files[1]), skip="Overview of removed sequences"))
cutLogs <- cutLogs[,1:2]
colnames(cutLogs) <- c("length", gsub(".log", "",cutLogs.files[1]))

for(i in 2:length(cutLogs.files)){
  tmp <- suppressWarnings(fread(file.path(projFolder, "logs", "CUTADAPT", cutLogs.files[i]), skip="Overview of removed sequences"))
  tmp <- tmp[,1:2]
  colnames(tmp) <- c("length", gsub(".log", "", cutLogs.files[i]))
  
  cutLogs <- merge(cutLogs, tmp, all=TRUE)
}

cutLogs[is.na(cutLogs)] <- 0
```

```{r}
tmp <- apply(cutLogs[,-1],1,mean)
names(tmp) <- as.vector(as.matrix(cutLogs[,1]))
tmp <- sort(tmp, decreasing=TRUE)[1:10]
tmp2 <- data.frame(names(tmp), tmp)
out_html <- knitr::kable(tmp2, col.names = c("Trimmed bases", "Avg. freq"), row.names = FALSE, "html")
kable_styling(out_html, "striped", position = "left")
```

### Summary
```{r trimmed data summary stats}
mqcStats.trim <- read.table(file.path(projFolder,"QC","TRIMMED","multiqc_R1", "multiqc_data", "multiqc_fastqc.txt"), header=TRUE, sep="\t")
tmp <- mqcStats.trim[,-c(1:4,7,11:21)]

totalTrimSequences <- sum(mqcStats.trim$Total.Sequences)
out <- c(totalTrimSequences,apply(tmp,2,mean))
names(out) <- c("Tot. number sequences",
                "Avg. total sequences",
                "Avg. poor quality",
                "Avg. GC Percent",
                "Avg. deplication percent",
                "Avg. sequence length")

out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), col.names = NULL, "html")
kable_styling(out_html, "striped", position = "left")

out <- t(as.data.frame(as.matrix((summary(tmp[,1])))))
rownames(out) <- "5-point summary of total sequences"
out_html <- knitr::kable(formatC(out,  format="d", big.mark=","), "html")
kable_styling(out_html, "striped", position = "left")

```


## Concatenated vs. Trimmed

```{r average trimmed and conc}
conFastQC.avg <- (conFastQC.R1[,-c(1:4,7,11:21)] + conFastQC.R2[,-c(1:4,7,11:21)]) / 2
trimmedFastQC.avg <- (trimmedFastQC.R1[,-c(1:4,7,11:21)] + trimmedFastQC.R2[,-c(1:4,7,11:21)]) / 2
conFastQC.avg$Sample <- conFastQC.R1$Sample
trimmedFastQC.avg$Sample <- trimmedFastQC.R1$Sample

conFastQCJSON.avg <- list()
conFastQCJSON.avg$sequenceQuality <- (conFastQCJSON.R1$sequenceQuality + conFastQCJSON.R2$sequenceQuality)/2
conFastQCJSON.avg$perBaseN <- (conFastQCJSON.R1$perBaseN + conFastQCJSON.R2$perBaseN)/2
trimmedFastQCJSON.avg <- list()
trimmedFastQCJSON.avg$sequenceQuality <- (trimmedFastQCJSON.R1$sequenceQuality + trimmedFastQCJSON.R2$sequenceQuality)/2
trimmedFastQCJSON.avg$perBaseN <- (trimmedFastQCJSON.R1$perBaseN + trimmedFastQCJSON.R2$perBaseN)/2
```

### De-Duplication percent

```{r conctrim data duplication percent}
par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.avg, trimmedFastQC.avg, labels=c("Conc", "Trimmed"), feature="total_deduplicated_percentage")
```

### GC content

```{r conctrim data qc content}
par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.avg, trimmedFastQC.avg, labels=c("Conc", "Trimmed"), feature="X.GC")
```

### Sequence length

```{r conctrim data sequence length}
par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.avg, trimmedFastQC.avg, labels=c("Conc", "Trimmed"), feature="avg_sequence_length")
```

### Total sequences

```{r conctrim data total sequences}
par(mar=c(10,5,1,1))
plotFastQCFeature(conFastQC.avg, trimmedFastQC.avg, labels=c("Conc", "Trimmed"), feature="Total.Sequences")
```

### Per base N content (left: Conc., right: Trimmed)
```{r contrimm data per base n content}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="perBaseN")

plotMQCFeature(x=file.path(projFolder,"QC","CONCATENATED","multiqc_R1"),
               y=file.path(projFolder,"QC","TRIMMED","multiqc_R1"),
               feature="fastqc_per_base_n_content_plot")
```

### Per base quality (left: R1, right: R2)
```{r contrimm data per base sequence quality}
par(mar=c(5,5,1,1))
#plotFastQCJSONFeature(conFastQCJSON.R1, conFastQCJSON.R2, feature="sequenceQuality")

plotMQCFeature(x=file.path(projFolder,"QC","CONCATENATED","multiqc_R1"),
               y=file.path(projFolder,"QC","TRIMMED","multiqc_R1"),
               feature="fastqc_per_base_sequence_quality_plot")
```
